// =====================================================
//  @rotest <grupoRO> [IG_Grupo | ItemID | AegisName] [qtd]
//  Ex.: @rotest armor
//       @rotest armor IG_ROTEST_ARMOR 5
//       @rotest armor Adventure_Suit 2
//       @rotest sword 1204 10
//  Requer: npc/custom/include/ro_data_from_csv.txt (gerado do CSV)
//  Obs.:  Gera item com random options do grupo e refino fixo +9 (sem grade/nível).
// =====================================================
-	script	ROTestCmd	-1,{

OnInit:
	bindatcmd "rotest", strnpcinfo(3)+"::OnCmd";
	debugmes "[ROTestCmd] pronto (modo: random options + refine +9, sem grade).";
	end;

OnCmd:
	// ---------- parametros ----------
	.@argc = .@atcmd_numparameters;
	if (.@argc < 1) {
		dispbottom "Uso: @rotest <grupoRO> [IG_Grupo | ItemID | AegisName] [qtd]";
		end;
	}

	.@grp$ = .@atcmd_parameters$[0]; // grupo do CSV

	// Confere existencia do grupo no include gerado
	.@ok = 0;
	for (.@i=0; .@i<$ro_groups_count; .@i++)
		if ($@ro_groups$[.@i] == .@grp$) { .@ok = 1; break; }
	if (!.@ok) { dispbottom "[ROTest] Grupo "+.@grp$+" nao existe no CSV."; end; }

	// Resolve item alvo (ID / Aegis / IG_)
	.@iid = 0; .@iname$ = "";
	if (.@argc >= 2) {
		.@arg1$ = .@atcmd_parameters$[1];
		if (getstrlen(.@arg1$) >= 3 && substr(.@arg1$,0,3) == "IG_") {
			.@iid = groupranditem(getd(.@arg1$), 1);
		} else {
			.@iid = atoi(.@arg1$);
			if (.@iid <= 0) .@iname$ = .@arg1$;
		}
	}
	// Fallback simples
	if (.@iid <= 0 && .@iname$ == "") {
		if (.@grp$ == "armor")       .@iid = groupranditem(IG_ROTEST_ARMOR, 1);
		else if (.@grp$ == "weapon") .@iid = groupranditem(IG_ROTEST_WEAPON, 1);
		if (.@iid <= 0) .@iname$ = "Adventure_Suit";
	}
	if (.@iid <= 0 && .@iname$ == "") { dispbottom "[ROTest] Item alvo invalido."; end; }

	// Quantidade (gera 1 por iteração; refine fixo +9)
	.@qty = (.@argc >= 3) ? atoi(.@atcmd_parameters$[2]) : 1;
	if (.@qty <= 0) .@qty = 1;

	// ---------- regras do grupo ----------
	.@slotcount  = getd("$ro_slotcount_"+.@grp$);
	.@rand_slots = getd("$rorand_slots_"+.@grp$);
	.@rand_size  = getd("$rorand_size_"+.@grp$);

	// ---------- gerar ----------
	for (.@t=0; .@t<.@qty; .@t++) {

		// Limpa os vetores
		deletearray .@OptID[0], getarraysize(.@OptID);
		deletearray .@OptVal[0], getarraysize(.@OptVal);
		deletearray .@OptParam[0], getarraysize(.@OptParam);

		// ---- FIXED SLOTS (um pick ponderado por slot) ----
		for (.@si=0; .@si<.@slotcount; .@si++) {
			.@slot = getd("$@ro_slotnums_"+.@grp$+"["+.@si+"]");
			.@sz   = getd("$rok_size_"+.@grp$+"_"+.@slot);
			if (.@sz <= 0) continue;

			// soma de chances
			.@sum = 0;
			for (.@i=0; .@i<.@sz; .@i++)
				.@sum += getd("$@roch_"+.@grp$+"_"+.@slot+"["+.@i+"]");
			if (.@sum <= 0) continue;

			// sorteio ponderado
			.@r = rand(1, .@sum);
			.@acc = 0;
			for (.@i=0; .@i<.@sz; .@i++) {
				.@acc += getd("$@roch_"+.@grp$+"_"+.@slot+"["+.@i+"]");
				if (.@r <= .@acc) { .@pick = .@i; break; }
			}

			// dados da opcao (usa min/max originais; sem multiplicador)
			.@key$  = getd("$@rok_"+.@grp$+"_"+.@slot+"$["+.@pick+"]");
			.@min   = getd("$@romin_"+.@grp$+"_"+.@slot+"["+.@pick+"]");
			.@max   = getd("$@romax_"+.@grp$+"_"+.@slot+"["+.@pick+"]");
			.@param = getd("$@roparam_"+.@grp$+"_"+.@slot+"["+.@pick+"]");

			// converte pra ID e valor
			.@optid = getd("RDMOPT_"+.@key$);
			if (.@optid <= 0) continue;

			.@val = rand(.@min, .@max);
			if (.@val == 0) continue; // evita "±0%"

			// PUSH
			.@n = getarraysize(.@OptID);
			.@OptID[.@n]    = .@optid;
			.@OptVal[.@n]   = .@val;
			.@OptParam[.@n] = .@param;

			if (getarraysize(.@OptID) >= 5) break;
		}

		// ---- RANDOM POOL (até MaxRandom, sem repetição) ----
		if (getarraysize(.@OptID) < 5 && .@rand_slots > 0 && .@rand_size > 0) {
			deletearray .@rch[0], getarraysize(.@rch);
			for (.@i=0; .@i<.@rand_size; .@i++)
				.@rch[.@i] = getd("$@rorand_ch_"+.@grp$+"["+.@i+"]");

			for (.@pickn=0; .@pickn<.@rand_slots; .@pickn++) {
				.@sum = 0;
				for (.@i=0; .@i<.@rand_size; .@i++) .@sum += .@rch[.@i];
				if (.@sum <= 0) break;

				.@r = rand(1, .@sum); .@acc = 0;
				for (.@i=0; .@i<.@rand_size; .@i++) {
					.@acc += .@rch[.@i];
					if (.@r <= .@acc) { .@pick = .@i; break; }
				}
				.@rch[.@pick] = 0; // sem repeticao

				// dados (sem multiplicador)
				.@key$  = getd("$@rorand_k_"+.@grp$+"$["+.@pick+"]");
				.@min   = getd("$@rorand_min_"+.@grp$+"["+.@pick+"]");
				.@max   = getd("$@rorand_max_"+.@grp$+"["+.@pick+"]");
				.@param = getd("$@rorand_param_"+.@grp$+"["+.@pick+"]");

				.@optid = getd("RDMOPT_"+.@key$);
				if (.@optid <= 0) continue;

				.@val = rand(.@min, .@max);
				if (.@val == 0) continue;

				// PUSH
				.@n = getarraysize(.@OptID);
				.@OptID[.@n]    = .@optid;
				.@OptVal[.@n]   = .@val;
				.@OptParam[.@n] = .@param;

				if (getarraysize(.@OptID) >= 5) break;
			}
		}

		// ----- ENTREGA (+9) -----
		// completa faltantes com zero

		// getitem3: <id/name>, amount=1, identified=1, refine=9, attribute=0, cards=0,0,0,0, arrays
		if (.@iid > 0)
			getitem3 .@iid,1, 1,9,0, 0,0,0,0, .@OptID, .@OptVal, .@OptParam;
		else
			getitem3 .@iname$,1, 1,9,0, 0,0,0,0, .@OptID, .@OptVal, .@OptParam;
	}

	dispbottom "[ROTest] OK: "+.@qty+"x "+.@grp$+" (refine +9, sem grade).";
	end;
}

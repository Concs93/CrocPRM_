//============================================================
// Astrologia Dungeons – Passo 1 (SIMPLIFICADO - sem Fase 2)
// Reset on exit: se o jogador sair da instância, ela é destruída
// (mata o MVP junto). Ao entrar novamente, uma nova instância limpa
// é criada e um novo boss nasce.
//============================================================
-	script	Ast_Farm_Step1	-1,{

	OnInit:
		.KILLS_REQUIRED   = 100;
		.INST_NAME$       = "Ast_MiniTrial";
		.INST_ENTRY_MAP$  = "guild_vs4"; // mapa de entrada
		.INST_ENTRY_X     = 50;
		.INST_ENTRY_Y     = 50;
		.COOLDOWN_SEC     = 2;
		.WATCH_MS         = 1000;

		// Boss
		.BOSS_ID    = 21602;          // C2_SAVAGE
		.BOSS_NAME$ = "Star Scourge Echo";
		.BOSS_X     = 100;
		.BOSS_Y     = 100;

		// HP do boss (sem fase 2)
		.BOSS_MAXHP     = 100000;

		// Estado de encontro (variáveis do NPC)
		.inst_iid       = 0;
		.inst_map$      = "";
		.ECO_GID        = 0;
		.instance_owner_aid = 0; // Armazena o AID do dono da instância
		.inst_watching  = 0;     // Watcher RID-free da instância (mata quando vazio)

		setmapflag "ast_dun01", mf_loadevent;
		setmapflag "ast_dun02", mf_loadevent;
		setmapflag "ast_dun03", mf_loadevent;

		end;






	// ---------- eventos ----------
	OnPCLoadMapEvent:
		.@m$  = strcharinfo(3);
		.@ins = instance_id();

		// reset ao ENTRAR em um dos 3 mapas
		if (.@m$=="ast_dun01" || .@m$=="ast_dun02" || .@m$=="ast_dun03") {
			if (@ast_kills) {
				@ast_kills = 0;
			}
			if (!@ast_watch) {
				@ast_watch = 1;
				@ast_prev_in_ast = 1;
				addtimer .WATCH_MS, strnpcinfo(3)+"::OnAstWatch";
			}
		}

		// NÃO destrói aqui; o watcher da instância cuidará quando ficar vazia
		end;

	OnPCLogoutEvent:
		@ast_watch = 0;
		// Nada a destruir aqui; OnInstWatch cuida quando ficar vazia.
		end;

	// ---------- kills ----------
	OnNPCKillEvent:
		callsub L_StepCounter;
		end;

	OnKillForward:
		callsub L_StepCounter;
		end;

	// ---------- step counter ----------
L_StepCounter:
	.@m$  = strcharinfo(3);
	.@ins = instance_id();

	if (.@ins > 0) { return; }
	if (.@m$!="ast_dun01" && .@m$!="ast_dun02" && .@m$!="ast_dun03") { return; }
	if (gettimetick(2) < @ast_cd_until) { return; }

	@ast_kills++;

	if (@ast_kills >= .KILLS_REQUIRED) {
		mapannounce .@m$, "Star Scourge: Let me end this intruder!", bc_map, 0xFF5040;

		@ast_kills = 0;
		@ast_cd_until = gettimetick(2) + .COOLDOWN_SEC;

		// espera 3s antes de criar a instância e warpar
		sleep2 3000;

		// salva AID (se precisar) e instancia
		@ast_aid = getcharid(0);
		attachrid(@ast_aid);

		.@iid = instance_create(.INST_NAME$, IM_CHAR);
		if (.@iid < 0) { return; }

		instance_enter(.INST_NAME$);
		.@imap$ = instance_mapname(.INST_ENTRY_MAP$, .@iid);
		if (.@imap$ == "") { return; }

		// >>> salvos em VARS DO NPC (sem @)
		.inst_iid  = .@iid;
		.inst_map$ = .@imap$;
		.instance_owner_aid = @ast_aid; // Salva o AID do dono

		@ast_prev_in_ast = 1;

		// salvar mapa + grace antes do warp
		@ast_inst_map$   = .@imap$;
		@ast_enter_grace = gettimetick(2) + 3;

		warp .@imap$, .INST_ENTRY_X, .INST_ENTRY_Y;

		@ast_iid = .@iid; @ast_inst_active = 1;
		if (!@ast_watch) { @ast_watch = 1; @ast_prev_in_ast = 1; addtimer .WATCH_MS, strnpcinfo(3)+"::OnAstWatch"; }
		if (!.inst_watching) { .inst_watching = 1; addtimer .WATCH_MS, strnpcinfo(3)+"::OnInstWatch"; }

		// baseline (se for bloquear MVP rewards depois)
		@ast_base_cws = countitem("C_World_Star");
		@ast_base_jsd = countitem("Jewel_Shadowdecon");

		@ast_boss_spawned = 0;
		callsub L_SpawnBoss, .@imap$;

	}
	return;

	// ===== Watchdog por player (cosmético) =====
OnAstWatch:
	if (!@ast_watch) end;
	.@m$  = strcharinfo(3);
	.@ins = instance_id();
	.@in_ast = (.@m$=="ast_dun01" || .@m$=="ast_dun02" || .@m$=="ast_dun03");
	@ast_prev_in_ast = .@in_ast;
	addtimer .WATCH_MS, strnpcinfo(3)+"::OnAstWatch";
	end;

	// ===== Watcher da instância (RID-free): destrói quando ficar vazia =====
OnInstWatch:
	if (.inst_iid > 0 && .inst_map$ != "") {
		.@users = getmapusers(.inst_map$);
		if (.@users <= 0) {
			// Limpeza do controller e instancia
			donpcevent "Ast_P2Ctrl::OnCleanup";
			// (Opcional) martelo: garante que nenhum boss fique ativo nesse mapa
			killmonster .inst_map$, strnpcinfo(3)+"::OnAstBossKilled";
			instance_destroy(.inst_iid);
			// Reset de variáveis
			.inst_iid = 0; .inst_map$ = ""; .instance_owner_aid = 0; .ECO_GID = 0;
			@ast_iid = 0; @ast_inst_active = 0; @ast_boss_spawned = 0;
			.inst_watching = 0;
			end;
		}
	}
	addtimer .WATCH_MS, strnpcinfo(3)+"::OnInstWatch";
	end;

	// ===== Spawn do boss no mapa instanciado =====
L_SpawnBoss:
	// Pega o mapa passado e evita respawn (mesma death-label)
	.@imap$ = getarg(0);
	if (.@imap$ == "") return;

	if (mobcount(.@imap$, strnpcinfo(3)+"::OnAstBossKilled") > 0) {
		return;
	}

	// evita multi-spawn por char
	if (@ast_boss_spawned) return;
	@ast_boss_spawned = 1;

	// bloqueia todos os drops (normais + MVP)
	setmapflag .@imap$, mf_nomobloot;
	setmapflag .@imap$, mf_noloot;

	// posição: ponto de entrada + 10 pra cima
	@ast_inst_map$ = .@imap$;
	@ast_boss_x = .INST_ENTRY_X;
	@ast_boss_y = .INST_ENTRY_Y + 10;

	set $@mobid[0], 0;
	// spawn do boss (captura correta do GID via $@mobid[0])
	monster .@imap$, @ast_boss_x, @ast_boss_y, .BOSS_NAME$, .BOSS_ID, 1, strnpcinfo(3)+"::OnAstBossKilled";
	sleep2 200;  // Aguarda para garantir spawn
	.@gid = $@mobid[0];

	if (.@gid > 0) {
		// Salva o GID
		.ECO_GID  = .@gid;
		.instance_owner_aid = getcharid(0); // Salva quem criou a instância

		// ======= (1) Ajusta status do boss ANTES de ligar o controller =======
		// Aguarda um pouco antes de modificar stats
		sleep2 300;

		// pega modo atual via array
		getunitdata .@gid, .@u;
		.@mode = .@u[UMOB_MODE];
		setunitdata .@gid, UMOB_MODE, ( .@mode &~ MD_BOSS );

		// FORÇA HP correto: primeiro MaxHP, depois HP atual
		setunitdata .@gid, UMOB_MAXHP, .BOSS_MAXHP;
		sleep2 100;
		setunitdata .@gid, UMOB_HP, .BOSS_MAXHP;
		sleep2 100;

		// Verifica se funcionou
		getunitdata .@gid, .@chk;
		.@check_maxhp = .@chk[UMOB_MAXHP];
		.@check_hp    = .@chk[UMOB_HP];

		if (.@check_hp != .BOSS_MAXHP || .@check_maxhp != .BOSS_MAXHP) {
			setunitdata .@gid, UMOB_MAXHP, .BOSS_MAXHP;
			setunitdata .@gid, UMOB_HP, .BOSS_MAXHP;
		}

		// ======= (2) Só agora amarra e inicia o controller P2 =======
		set getvariableofnpc(.inst_iid,  "Ast_P2Ctrl"), .inst_iid;
		set getvariableofnpc(.inst_map$, "Ast_P2Ctrl"), .inst_map$;
		set getvariableofnpc(.ECO_GID,   "Ast_P2Ctrl"), .ECO_GID;
		// guardando dono
		set getvariableofnpc(.owner_aid, "Ast_P2Ctrl"), .instance_owner_aid;
		// Inicia o loop do controller P2 com HP já correto
		donpcevent "Ast_P2Ctrl::OnBind";

	} else {
		@ast_boss_spawned = 0; // libera re-tentativa
	}

	return;

	// ===== Kill do boss → Dust + warp fixo + destruir =====
OnAstBossKilled:
	if (killerrid) attachrid(killerrid);
	if (getcharid(3) <= 0) end;

	// fala final
	mapannounce .inst_map$, "Star Scourge: You think you've accomplished something? You're pathetic!", bc_map, 0xFF4040;
	donpcevent "Ast_P2Ctrl::OnCleanup";
	// Recompensa da instância
	getitem "Galactic_Dust", 5;

	// 3s depois: warp FIXO e destrói a instância
	sleep2 3000;
	warp "ast_dun01", 43, 16;

	if (@ast_inst_active && @ast_iid > 0) {
		instance_destroy(@ast_iid);
		@ast_iid = 0;
		@ast_inst_active = 0;
		// Limpa variáveis da instância
		.inst_iid = 0; .inst_map$ = ""; .instance_owner_aid = 0;
		.ECO_GID = 0;
	}
	@ast_boss_spawned = 2; // sem respawn
	end;

}
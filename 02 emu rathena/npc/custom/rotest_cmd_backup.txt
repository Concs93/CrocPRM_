-	script	ROTestCmd	-1,{

OnInit:
	// Uso:
	//   @rotest <grupoRO> [IG_Grupo | ItemID | AegisName] [qtd] [grade]
	// Ex.: @rotest armor
	//      @rotest armor IG_ROTEST_ARMOR 5
	//      @rotest armor Adventure_Suit 2 3
	//      @rotest sword 1204 10 G5
	bindatcmd "rotest", strnpcinfo(3)+"::OnCmd";
	debugmes "[ROTestCmd] pronto.";
	end;

OnCmd:
	// ---------- parâmetros ----------
	.@argc = .@atcmd_numparameters;
	if (.@argc < 1) {
		dispbottom "Uso: @rotest <grupoRO> [IG_Grupo | ItemID | AegisName] [qtd] [grade(0..5)]";
		end;
	}

	.@grp$ = .@atcmd_parameters$[0]; // nome do grupo do CSV (ex.: armor, sword, shoes, ...)
	// confirma que existe no include
	.@ok = 0;
	for (.@i=0; .@i<$ro_groups_count; .@i++)
		if ($@ro_groups$[.@i] == .@grp$) { .@ok = 1; break; }
	if (!.@ok) { dispbottom "[ROTest] Grupo '"+.@grp$+"' nao existe no CSV."; end; }

	// resolve item (ID/Aegis/IG_)
	.@iid = 0; .@iname$ = "";
	if (.@argc >= 2) {
		.@arg1$ = .@atcmd_parameters$[1];
		if (getstrlen(.@arg1$) >= 3 && substr(.@arg1$,0,3) == "IG_") {
			.@iid = groupranditem(getd(.@arg1$), 1);
		} else {
			.@iid = atoi(.@arg1$);
			if (.@iid <= 0) .@iname$ = .@arg1$;
		}
	}
	// se não passou item, tenta pegar um ao acaso do seu grupo “wrapper” (se você tiver grupos IG_ROTEST_*)
	if (.@iid <= 0 && .@iname$ == "") {
		// exemplo: se tiver IG_ROTEST_ARMOR pra testar armors
		if (.@grp$ == "armor")      .@iid = groupranditem(IG_ROTEST_ARMOR, 1);
		else if (.@grp$ == "weapon") .@iid = groupranditem(IG_ROTEST_WEAPON, 1);
		// senão, usa um fallback bobo
		if (.@iid <= 0) .@iname$ = "Adventure_Suit";
	}
	if (.@iid <= 0 && .@iname$ == "") { dispbottom "[ROTest] Item alvo invalido."; end; }

	// quantidade
	.@qty = (.@argc >= 3) ? atoi(.@atcmd_parameters$[2]) : 1;
	if (.@qty <= 0) .@qty = 1;

	// grade (0..5). Pode ser "G3" / "g3" ou só "3". Se omitir: aleatória 0..5
	.@grade = -1;
	if (.@argc >= 4) {
		.@g$ = .@atcmd_parameters$[3];
		if (getstrlen(.@g$) >= 2 && ( substr(.@g$,0,1) == "G" || substr(.@g$,0,1) == "g" )) {
			.@grade = atoi(substr(.@g$, 1, getstrlen(.@g$)-1));
		} else {
			.@grade = atoi(.@g$);
		}
	}
	if (.@grade < 0 || .@grade > 5) .@grade = rand(0,5);

	// multiplicadores por grade (0..5) -> 100%, 120%, 140%, 170%, 200%, 250% (+150% na última)
	setarray .@gmult[0], 100,120,140,170,200,250;
	.@mult = .@gmult[.@grade];

	// ---------- coleta das regras do grupo a partir do include ----------
	// slots fixos
	.@slotcount = getd("$ro_slotcount_"+.@grp$);
	// random pool
	.@rand_slots = getd("$rorand_slots_"+.@grp$);
	.@rand_size  = getd("$rorand_size_"+.@grp$);

	// ---------- gera ----------
	for (.@t=0; .@t<.@qty; .@t++) {

		// zera arrays de opções
		deletearray .@OptID[0], getarraysize(.@OptID);
		deletearray .@OptVal[0], getarraysize(.@OptVal);
		deletearray .@OptParam[0], getarraysize(.@OptParam);

		// ---- slots fixos: para cada slot do grupo, escolher UMA opção ponderada pela chance ----
		for (.@si=0; .@si<.@slotcount; .@si++) {
			.@slot = getd("$@ro_slotnums_"+.@grp$+"["+.@si+"]");
			.@sz   = getd("$rok_size_"+.@grp$+"_"+.@slot);
			if (.@sz <= 0) continue;

			// soma das chances do slot
			.@sum = 0;
			for (.@i=0; .@i<.@sz; .@i++)
				.@sum += getd("$@roch_"+.@grp$+"_"+.@slot+"["+.@i+"]");
			if (.@sum <= 0) continue;

			// sorteia índice ponderado
			.@r   = rand(1, .@sum);
			.@acc = 0;
			for (.@i=0; .@i<.@sz; .@i++) {
				.@acc += getd("$@roch_"+.@grp$+"_"+.@slot+"["+.@i+"]");
				if (.@r <= .@acc) { .@pick = .@i; break; }
			}

			// lê dados da opção
			.@key$  = getd("$@rok_"+.@grp$+"_"+.@slot+"$["+.@pick+"]");
			.@min   = getd("$@romin_"+.@grp$+"_"+.@slot+"["+.@pick+"]");
			.@max   = getd("$@romax_"+.@grp$+"_"+.@slot+"["+.@pick+"]");
			.@param = getd("$@roparam_"+.@grp$+"_"+.@slot+"["+.@pick+"]");

			// converte para ID de random option
			.@optid = getd("RDMOPT_"+.@key$);
			if (.@optid <= 0) continue;

			// valor com multiplicador de grade (ceil)
			.@base = rand(.@min, .@max);
			.@val  = ( .@base * .@mult + 99 ) / 100;

			// push
			.@n = getarraysize(.@OptID);
			.@OptID[.@n]   = .@optid;
			.@OptVal[.@n]  = .@val;
			.@OptParam[.@n]= .@param;

			// limite duro de 5 opções totais (client/servidor usam 5 slots)
			if (getarraysize(.@OptID) >= 5) break;
		}

		// ---- random pool: pega até MaxRandom entradas sem repetição, ponderado por chance ----
		if (getarraysize(.@OptID) < 5 && .@rand_slots > 0 && .@rand_size > 0) {
			// cópia das chances para podermos zerar itens escolhidos (sem repetição)
			deletearray .@rch[0], getarraysize(.@rch);
			for (.@i=0; .@i<.@rand_size; .@i++)
				.@rch[.@i] = getd("$@rorand_ch_"+.@grp$+"["+.@i+"]");

			for (.@pickn=0; .@pickn<.@rand_slots; .@pickn++) {
				// soma atual
				.@sum = 0;
				for (.@i=0; .@i<.@rand_size; .@i++) .@sum += .@rch[.@i];
				if (.@sum <= 0) break;

				.@r = rand(1, .@sum);
				.@acc = 0;
				for (.@i=0; .@i<.@rand_size; .@i++) {
					.@acc += .@rch[.@i];
					if (.@r <= .@acc) { .@pick = .@i; break; }
				}
				// marca como usado
				.@rch[.@pick] = 0;

				// lê dados
				.@key$  = getd("$@rorand_k_"+.@grp$+"$["+.@pick+"]");
				.@min   = getd("$@rorand_min_"+.@grp$+"["+.@pick+"]");
				.@max   = getd("$@rorand_max_"+.@grp$+"["+.@pick+"]");
				.@param = getd("$@rorand_param_"+.@grp$+"["+.@pick+"]");
				.@optid = getd("RDMOPT_"+.@key$);
				if (.@optid <= 0) continue;

				.@base = rand(.@min, .@max);
				.@val  = ( .@base * .@mult + 99 ) / 100;

				// push
				.@n = getarraysize(.@OptID);
				.@OptID[.@n]   = .@optid;
				.@OptVal[.@n]  = .@val;
				.@OptParam[.@n]= .@param;

				if (getarraysize(.@OptID) >= 5) break;
			}
		}

		// entrega identificado
		if (.@iid > 0)
			getitem3 .@iid, 1, 1, 0, 0, 0,0,0,0, .@OptID, .@OptVal, .@OptParam;
		else
			getitem3 .@iname$, 1, 1, 0, 0, 0,0,0,0, .@OptID, .@OptVal, .@OptParam;
	}

	dispbottom "[ROTest] OK: "+.@qty+"x item(s) do grupo '"+.@grp$+"'  Grade="+.@grade+" (x"+.@mult+"%).";
	end;
}
